from langchain_huggingface import HuggingFaceEndpoint
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, model_validator, Field
from dotenv import load_dotenv
import os
from database import insert_goal, close_connection, db
from datetime import datetime 

# Load environment variables from the .env file
load_dotenv()  # This loads all the variables from the .env file into environment

# Access the API key using os.getenv()
api_key = os.getenv("HF_API_KEY")
if not api_key:
    raise ValueError("HF_API_KEY environment variable is not set")

# Instantiate FastApi app
app = FastAPI()

# Pydantic BaseModel
class PredInput(BaseModel):
    name: str = Field(..., min_length=3, max_length=100, example="My Goal")
    description: str = Field(..., min_length=10, max_length=500, example="A detailed description of the goal.")
    deadline: str

    @model_validator
    def check_deadline(cls, values):
        deadline = values.get("deadline")
        try:
            datetime.strptime(deadline, "%d/%m/%Y")
        except ValueError:
            raise ValueError("Deadline should be in the format DD/MM/YYYY")
        return values
    
    @model_validator(pre=True)
    def check_non_empty_fields(cls, values):
        if not values.get('name') or not values.get('description'):
            raise ValueError('Both name and description cannot be empty.')
        return values

# Configuring Langchain with HuggingFace LLM
llm = HuggingFaceEndpoint(
    repo_id="microsoft/Phi-3.5-mini-instruct",  
    model_kwargs={"max_length": 500},  # Tokens limit output
    huggingfacehub_api_token=api_key          
)

# Step 1: Define prompts for each part of the SMART goal
specific_template = "Help me define a specific goal based on the following: {description}"
measurable_template = "How can we measure the success of the following goal: {description}"
achievable_template = "How can we make this goal achievable: {description}"
relevant_template = "Why is this goal relevant to my broader objectives: {description}"
time_bound_template = "What is a time-bound plan to achieve the goal: {description}"

# Step 2: Create Langchain Prompts for each SMART criteria
specific_prompt = PromptTemplate(input_variables=["description"], template=specific_template)
measurable_prompt = PromptTemplate(input_variables=["description"], template=measurable_template)
achievable_prompt = PromptTemplate(input_variables=["description"], template=achievable_template)
relevant_prompt = PromptTemplate(input_variables=["description"], template=relevant_template)
time_bound_prompt = PromptTemplate(input_variables=["description"], template=time_bound_template)

# Step 3: Instantiate LLMChain for each prompt
specific_chain = LLMChain(prompt=specific_prompt, llm=llm)
measurable_chain = LLMChain(prompt=measurable_prompt, llm=llm)
achievable_chain = LLMChain(prompt=achievable_prompt, llm=llm)
relevant_chain = LLMChain(prompt=relevant_prompt, llm=llm)
time_bound_chain = LLMChain(prompt=time_bound_prompt, llm=llm)

# Step 4: Combine the chains into a multi-step goal generation process
def generate_smart_plan(description: str):
    specific = specific_chain.run({"description": description})
    measurable = measurable_chain.run({"description": description})
    achievable = achievable_chain.run({"description": description})
    relevant = relevant_chain.run({"description": description})
    time_bound = time_bound_chain.run({"description": description})
    
    return {
        "Specific": specific,
        "Measurable": measurable,
        "Achievable": achievable,
        "Relevant": relevant,
        "Time-bound": time_bound
    }

# FastAPI endpoint for home route
@app.get("/")
def read_root():
    return {"message": "Welcome to AI Goal Setter!"}

# FastAPI endpoint for generating the SMART goal plan
@app.post('/generate-plan/')
async def generate_plan(prompt: PredInput):
    try:
        # Generate SMART goal components
        goal_plan = generate_smart_plan(prompt.description)

        # Insert goal into the database
        insert_goal(prompt.name, prompt.description, prompt.deadline, str(goal_plan))

        return {
            "project_name": prompt.name,
            "goal_plan": goal_plan  # Return structured SMART goal components
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=(f'Error in generating model: {str(e)}')) 
      
    finally:
        close_connection()

# FastAPI endpoint to retrieve a specific goal by ID
@app.get("/get-goal/{goal_id}")
async def get_goal(goal_id: int):
    try:
        query = f"SELECT * FROM goals WHERE id = %s"
        with db.cursor() as cursor:  # Here the cursor is used to interact with the DB
            cursor.execute(query, (goal_id,))
            goal = cursor.fetchone()

        if not goal:
            raise HTTPException(status_code=404, detail="Goal not found")

        return goal  # Return the goal data

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving goal: {str(e)}")

    finally:
        close_connection()  # Close the connection (if necessary)

# FastAPI endpoint to retrieve all goals
@app.get("/get-all-goals")
async def get_all_goals():
    try:
        query = "SELECT * FROM goals"
        with db.cursor() as cursor:
            cursor.execute(query)
            goals = cursor.fetchall()

        return {"goals": goals}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving goals: {str(e)}")

    finally:
        close_connection()
